package udacity

import (
  "dlluncor/myio"
  "strconv"
  "fmt"
  "strings"
)

// GraphSearch implements a general graph search application, such as A* or BFS
// or DFS.
/*
func GraphSearch(fronteir Fronteir, explored Explored, searcher Searcher) bool {
  for {
    if fronteir.IsEmpty() {
    	return false
    }
    node := fronteir.RemoveChoice()
    s = node.state // What node we are at currently in this path.
    explored.Add(s) // We've now seen this node.
    if searcher.IsGoal(node) {
    	return true
    }
    actions := searcher.NextActions(node)
    for a, _ range actions {
    	if !fronteir.Contains(a) && !explored.Contains(a) { 
    	  searcher.AddAction(a)
    	}
    }
  }
}
*/

var (
  BLANK = 16 // The number 16 indicates blank.
)

// Takes two indices and swaps their values, returning a new board.
func SwapThem(blankIndex, filledIndex, []int board) []int {
  newBoard := make([]int, 16)
  copy(newBoard, board)
  newBoard[blankIndex] = board[filledIndex]
  newBoard[filledIndex] = BLANK
  return newBoard
}

// Returns an array of possible new boards given the current board state.
func FindAdjacents(board []int) [][]int {
  // Find the location of the blank.
  numToLoc := make(map[int]int)
  for index, num := range board {
    numToLoc[num] = index
  }
  blankIndex := numToLoc[16]

  // Find adjacent locations to this one.
  possibIndices := []int{blankIndex-1, blankIndex-4, blankIndex+1, blankIndex+4}
  newBoards := make([][]int, 0)
  for _, possibInd := range possibIndices {
    if possibInd < 16 {
      // Here we can swap.
      // Create a new array of elements which we can swap.
      newBoard := SwapThem(blankIndex, possibInd, board)
      newBoards = append(newBoards, newBoard)
    }
  }
  return newBoards
}

// StringBoard returns the board as a string.
func StringBoard(board []int) string{
  str := ""
  for _, integer := range board {
    str += fmt.Sprintf("%d", integer)
  }
  return str
}

type BFronteir {
  strToBoard map[string] []int // Maps from string rep of board to actual board.
} 

// Adds a board to the fronteir.
func (b *BFronteir) Add(board []int) {
  stringRep := StringBoard(board)
  b.strToBoard[stringRep] = board
}

func (b *BFronteir) IsEmpty() bool {
  return len(b.strToBoard) == 0
}

type BoardSolver struct {
  fronteir BFronteir
}

func (bs *BoardSolver) Init(board []int) {
  // Fronteir consists of current board.
  bs.fronteir = &BFronteir{}
  bs.fronteir.Add(board)

  // Each time we check the fronteir, we explore all the new possible ones.
  //adjacents := FindAdjacents(board)
  
  // Create states where adjacent cells move into the blank spot.
  //for _, anotherBoard := range adjacents {
   // anotherState := &BState{anotherBoard}
 // }
}

func (bs *BoardSolver) IsEmpty() {
  return bs.fronteir.IsEmpty()
}

func (bs *BoardSolver) RemoveChoice() {
  return bs.fronteir.RemoveChoice()
}


// General board.

type Board struct {
  board []int
  bs BoardSolver
}

func (b *Board) Solve() {
  bs := &BoardSolver{}
  bs.Init(b.board)
  //GraphSearch(bs, bs, bs)
}

func (b *Board) Create(r myio.Reader) {
  b.board = make([]int, 16)

  // Read board from input.
  for i := 0; i < 4; i++ {
    nums := strings.Split(r.Read(), " ")
	  for j, num := range nums {
	    numI, _ := strconv.Atoi(num)
      k := i * 4 + j
      b.board[k] = numI
	   }
  }
}

func (b *Board) Print() {
  output := ""
  for i := 0; i < 4; i++ {
    line := ""
    for j := 0; j < 4; j++ {
      tab := "\t"
      if j == 0 {
        tab = ""
      }
      k := i * 4 + j
      line += fmt.Sprintf(tab + "%d", b.board[k])
    }
    output += line + "\n"
  }
  fmt.Printf("Current board: \n")
  fmt.Printf(output)
}

func FifteenNums() {
  r := myio.NewReader()
  board := &Board{}
  board.Create(r)
  board.Print()
  board.Solve()
}